import * as React from "react"
import {
    FrameProps,
    PropertyControls,
    Frame,
    addPropertyControls,
    ControlType,
} from "framer"

// Responsive Layout Component
// @steveruizok

const defaultStyle: React.CSSProperties = {
    height: "100%",
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center",
    textAlign: "center",
    color: "#333",
    fontSize: "3em",
    fontWeight: "bold",
    background: "rgba(255, 255, 255, 1)",
    border: "2px solid #eee",
    borderRadius: "2px",
    overflow: "hidden",
    padding: "16px",
}

const DefaultDisplay = props => (
    <div style={defaultStyle}>
        <p>R</p>
    </div>
)

// Define type of property
interface Props extends FrameProps {
    layouts: React.ReactElement<any>[]
}

export const ResponsiveLayout: React.FC<Props> = props => {
    const { layouts, ...rest } = props

    const rContainer = React.useRef<HTMLDivElement>()
    const [currentLayout, setCurrentLayout] = React.useState(layouts[0])

    React.useEffect(() => {
        const updateCurrentLayout = () => {
            const container = rContainer.current

            // Get the actual width of our component
            const componentWidth = container.offsetWidth
            const componentHeight = container.offsetHeight

            // Which layout should we show next?
            let nextLayout

            // If we don't have layouts, set the current layout to the default display
            if (layouts.length === 0) {
                nextLayout = <DefaultDisplay />
            } else if (layouts.length === 1) {
                // If there's only one frame connected, that's our current layout
                nextLayout = layouts[0]
            } else {
                // If we have more than one connected frame, we'll need to find
                // the widest frame that fits under our component's current width,
                // or else the most narrow connected frame.

                // 1. Create a copy of the connected frames
                const connected = [...layouts]

                // 2. Sort the connected frames in order of their width
                const sorted = connected.sort((frameA, frameB) =>
                    frameA.props.width > frameB.props.width ? 1 : -1
                )

                // 3. Filter sorted frames array to only those that fit
                // under the component's current width
                const filtered = sorted.filter(
                    frame => frame.props.width <= componentWidth
                )

                // 4. If the array is empty, then nothing fits, so return the
                // most narrow frame (the first frame in the sorted array).
                if (filtered.length === 0) {
                    nextLayout = sorted.shift()
                } else {
                    // Otherwise, return the widest frame to fit under the component's
                    // current width (the last frame in the filtered array)
                    nextLayout = filtered.pop()
                }
            }

            // If the next layout is the same as our current layout,
            // we don't have to update anything. If it's different,
            // then update the state and the rCurrentId ref, too.
            if (
                !currentLayout ||
                currentLayout.props.id !== nextLayout.props.id
            ) {
                setCurrentLayout(nextLayout)
            }
        }
        // We'll run the function now...
        updateCurrentLayout()

        // And also set a listener to run it when the user resizes the preview,
        // and we'll remove that listener when the effect cleans up.
        window.addEventListener("resize", updateCurrentLayout)
        return () => window.removeEventListener("resize", updateCurrentLayout)
    }, [layouts, currentLayout, props.height, props.width, props.size])

    // Whenever we get a new current layout, copy it and resize it
    const layout = React.useMemo(() => {
        if (!currentLayout) {
            return null
        }

        return React.cloneElement(currentLayout, {
            width: "100%",
            height: "100%",
        })
    }, [currentLayout])

    return (
        <Frame ref={rContainer} {...rest} width="100%" height="100%">
            {layout}
        </Frame>
    )
}

addPropertyControls(ResponsiveLayout, {
    layouts: {
        type: ControlType.Array,
        title: "Layouts",
        propertyControl: {
            type: ControlType.ComponentInstance,
        },
    },
})
